# 2. Memory: Ingestion

<pre>
â”œâ”€â”€ <a href="../README.md">..</a>
â”œâ”€â”€ <a href="./1.memory.md">1. Memory</a>
â”œâ”€â”€ <span><a href="./2.ingestion.md"><b>2. Ingestion</b></a> ðŸ‘ˆ</span>
|   â”œâ”€â”€ <a href="#21-scoring">2.1 Scoring</a>
|   â”œâ”€â”€ <a href="#22-classification">2.2 Classification</a>
|   â””â”€â”€ <a href="#23-storage">2.3 Storage</a>
â”œâ”€â”€ <a href="./3.guards.md">3. Guards</a>
â”œâ”€â”€ <a href="./4.recall.md">4. Recall</a>
â”œâ”€â”€ <a href="./5.classification.md">5. Classification</a>
â””â”€â”€ <a href="./README.md">â–¾ 6. Research/</a>
    â”œâ”€â”€ <a href="./merc/README.md">â–¸ 6.1 Merc/</a>
    â”œâ”€â”€ <a href="./reference/README.md">â–¸ 6.2 Reference/</a>
    â””â”€â”€ <a href="./analysis/README.md">â–¸ 6.3 Analysis/</a>
</pre>

**Memory Ingestion** is the process of transforming raw conversational text into a structured object with metadata that will make similarity based retrieval possible.

```mermaid
---
title: Memory Ingestion
---

flowchart TB
  %% Start / End
  START(( ))
  END(( ))

  %% Core stages
  Ingest([Ingest])
  Guards@{ shape: hex, label: "<a href='https://github.com/aacebo/merc/blob/main/docs/3.guards.md'>Guards</a>" }
  Score([Score])
  Drop([Drop])
  Classify([Classify])

  %% Memory types
  Episodic(["<a href='https://github.com/aacebo/merc/blob/main/docs/1.memory.md#episodic-events'>Episodic</a>"])
  Semantic(["<a href='https://github.com/aacebo/merc/blob/main/docs/1.memory.md#semantic-facts-concepts'>Semantic</a>"])
  Procedural(["<a href='https://github.com/aacebo/merc/blob/main/docs/1.memory.md#procedural-skills-habits'>Procedural</a>"])
  Emotional(["<a href='https://github.com/aacebo/merc/blob/main/docs/1.memory.md#emotional'>Emotional</a>"])
  Working(["<a href='https://github.com/aacebo/merc/blob/main/docs/1.memory.md#working-temporary'>Working</a>"])

  %% Post-processing
  Store@{ shape: cyl, label: 'Store' }
  Recall(["<a href='https://github.com/aacebo/merc/blob/main/docs/4.recall.md'>Recall</a>"])
  Reinforce([Reinforce])
  Reclassify([Reclassify])

  %% Flow
  START e1@--> Ingest
  e1@{ animate: true }

  Ingest e2@--> Guards
  e2@{ animate: true }

  Guards e3@-->|salience + emotion + meaning + context| Score
  e3@{ animate: true }

  Score -->|below threshold| Drop
  Drop --> END

  Score e4@-->|above threshold| Classify
  e4@{ animate: true }

  Classify e5@--> Episodic
  Classify e6@--> Semantic
  e6@{ animate: true }

  Classify e7@--> Procedural
  Classify e8@--> Emotional
  Classify e9@--> Working

  Episodic e10@--> Store
  Semantic e11@--> Store
  e11@{ animate: true }

  Procedural e12@--> Store
  Emotional e13@--> Store
  Working e14@--> Store

  Store e15@--> Recall
  e15@{ animate: true }

  Recall e16@--> Reinforce
  e16@{ animate: true }

  Reinforce e17@--> Reclassify
  e17@{ animate: true }

  Reclassify e18@--> Store
  e18@{ animate: true }

  %% --- Global link style: dotted ---
  linkStyle default stroke-width:2px,stroke-dasharray:4 4;

  %% --- Styling for the "Classify" node + path ---
  classDef success color:#ffffff,stroke:#118a11,fill:#0e5904;
  class Classify success;

  %% --- Styling for the "Drop" node + path ---
  classDef error color:#ffffff,stroke:#cc0000,fill:#660000;
  class Drop error;
  class END error;

  %% Override the Drop path links back to red (0-based edge indices)
  linkStyle 3 stroke:#cc0000,stroke-width:2px;
  linkStyle 4 stroke:#cc0000,stroke-width:2px;
  linkStyle 5 stroke:#118a11,stroke-width:2px;
  linkStyle 7 stroke:#118a11,stroke-width:2px;
  linkStyle 12 stroke:#118a11,stroke-width:2px;
  linkStyle 16 stroke:#118a11,stroke-width:2px;
  linkStyle 17 stroke:#118a11,stroke-width:2px;
  linkStyle 18 stroke:#118a11,stroke-width:2px;
  linkStyle 19 stroke:#118a11,stroke-width:2px;
```

## 2.1 Scoring

By measuring the input using a classifier against our significant [datapoints](./1.memory.md#14-datapoints), we can create a weighted score.

If said score is *under* our threshold, it is not worth remembering. Otherwise we continue on to further classification.

### How Scoring Works

The Merc scoring engine evaluates input text across **four independent dimensions** using zero-shot classification, then aggregates weighted predictions to produce a final importance score.

```mermaid
flowchart LR
    A[Input Text] --> B[Zero-Shot Classification]
    B --> C[Sentiment]
    B --> D[Emotion]
    B --> E[Outcome]
    B --> F[Context]

    C --> G[Aggregate]
    D --> G
    E --> G
    F --> G

    G --> H{Score >= 0.75?}
    H -->|Yes| I[ACCEPT]
    H -->|No| J[REJECT]

    style I fill:#22c55e,color:#fff
    style J fill:#ef4444,color:#fff
```

### Label Categories

| Category | Labels | Purpose |
|----------|--------|---------|
| **Sentiment** | Positive, Negative, Neutral | Basic emotional tone |
| **Emotion** | Joy, Fear, Shame, Pride, Stress, Anger, Sad | Specific emotional states |
| **Outcome** | Decision, Progress, Conflict, Success, Failure, Reward, Punishment | Life events and decisions |
| **Context** | Task, Plan, Goal, Preference, Fact, Entity, Time, Place, Phatic | Information type |

### Weight Hierarchy

```mermaid
flowchart LR
    A["Context<br/>max 1.00"] --> B["Outcome<br/>max 0.80"]
    B --> C["Emotion<br/>max 0.45"]
    C --> D["Sentiment<br/>max 0.35"]

    style A fill:#22c55e,color:#fff
    style B fill:#3b82f6,color:#fff
    style C fill:#f59e0b,color:#fff
    style D fill:#6b7280,color:#fff
```

**Context labels are prioritized** because they capture information most useful for memory systems:
- **Tasks** (1.00) and **Plans/Goals** (0.90) are weighted highest as explicit actionable items
- **Preferences** (0.85) and **Facts** (0.80) capture important personal information
- **Entity/Time/Place** (0.55-0.65) provide supporting context

For complete scoring algorithm details, see [Scoring Algorithm](./merc/scoring-algorithm.md).

## 2.2 Classification

Once text passes the scoring threshold, it is classified into one or more [memory types](./1.memory.md#13-types) based on the detected labels.

### Label to Memory Type Mapping

| Detected Labels | Primary Memory Type | Rationale |
|-----------------|---------------------|-----------|
| Task, Plan, Goal | [Procedural](./1.memory.md#procedural-skills-habits) | Actionable items become habits/skills |
| Fact, Entity | [Semantic](./1.memory.md#semantic-facts-concepts) | General knowledge storage |
| Time, Place + high context | [Episodic](./1.memory.md#episodic-events) | Time-bound events |
| Joy, Fear, Stress, etc. | [Emotional](./1.memory.md#emotional) | Emotion-strengthened encoding |
| Low score, borderline | [Working](./1.memory.md#working-temporary) | Temporary, may be promoted |

### Classification Flow

```mermaid
flowchart TD
    A[Scored Text] --> B{Task/Plan/Goal?}
    B -->|Yes| C[Procedural]
    B -->|No| D{Fact/Entity?}
    D -->|Yes| E[Semantic]
    D -->|No| F{Time/Place bound?}
    F -->|Yes| G[Episodic]
    F -->|No| H{Emotional labels?}
    H -->|Yes| I[Emotional]
    H -->|No| J[Working]
```

**Note:** A single memory can be stored in multiple types. For example, "I was so stressed about the meeting at 3pm" could be stored as both Emotional (stress) and Episodic (time-bound event).

## 2.3 Storage

Storage is handled by **downstream systems**â€”Merc is stateless and only provides scoring and classification signals.

### What Merc Provides

| Signal | Description | Downstream Use |
|--------|-------------|----------------|
| `score` | Overall importance (0.0-1.0) | Storage priority |
| `decision` | Accept/Reject | Gate write operations |
| `labels` | Detected labels with scores | Metadata enrichment |
| `category_scores` | Per-category aggregates | Type classification |

### What Downstream Systems Handle

| Concern | System | Notes |
|---------|--------|-------|
| Vector embedding | Storage layer | Semantic search |
| Entity extraction | LLM pipeline | Named entities, relationships |
| Temporal parsing | Downstream | Date/time extraction |
| Contradiction detection | Bi-temporal storage | Zep, Hindsight |
| PII masking | Compliance layer | Before storage |

### Storage Schema (Conceptual)

```
Memory {
    id: UUID
    content: String
    score: Float
    labels: [Label]
    memory_type: MemoryType
    created_at: Timestamp
    context: {
        thread_id: UUID
        previous_memory_id: UUID?
    }
}
```

For implementation details, see the storage crate documentation.

# 6.1.2.5 Output Enrichment

Structured output format for downstream system integration. **Zero latency impact**.

<pre>
â”œâ”€â”€ <a href="../../README.md">..</a>
â”œâ”€â”€ <a href="../../1.memory.md">â–¸ 1. Memory</a>
â”œâ”€â”€ <a href="../../2.ingestion.md">â–¸ 2. Ingestion</a>
â”œâ”€â”€ <a href="../../3.guards.md">â–¸ 3. Guards</a>
â”œâ”€â”€ <a href="../../4.recall.md">â–¸ 4. Recall</a>
â”œâ”€â”€ <a href="../../5.classification.md">â–¸ 5. Classification</a>
â””â”€â”€ <a href="../../README.md">â–¾ 6. Research/</a>
    â”œâ”€â”€ <a href="../README.md">â–¾ 6.1 Merc/</a>
    â”‚   â”œâ”€â”€ <a href="../scoring-algorithm.md">6.1.1 Scoring Algorithm</a>
    â”‚   â””â”€â”€ <a href="./README.md">â–¾ 6.1.2 Roadmap/</a>
    â”‚       â”œâ”€â”€ <a href="./1.foundation.md">6.1.2.1 Foundation</a>
    â”‚       â”œâ”€â”€ <a href="./2.labels.md">6.1.2.2 Label Expansion</a>
    â”‚       â”œâ”€â”€ <a href="./3.context.md">6.1.2.3 Context & Ensemble</a>
    â”‚       â”œâ”€â”€ <a href="./4.learning.md">6.1.2.4 Learning Infrastructure</a>
    â”‚       â””â”€â”€ <span><a href="./5.output.md"><b>6.1.2.5 Output Enrichment</b></a> ðŸ‘ˆ</span>
    â”œâ”€â”€ <a href="../../reference/README.md">â–¸ 6.2 Reference/</a>
    â””â”€â”€ <a href="../../analysis/README.md">â–¸ 6.3 Analysis/</a>
</pre>

---

## Overview

| ID | Task | Runtime Impact | Purpose |
|----|------|----------------|---------|
| MERC-013 | Structured ScoreResult | 0% | Downstream compatibility |
| MERC-014 | Temporal Metadata | 0% | Enable downstream temporal reasoning |

**Goal:** Provide rich output that downstream systems (Zep, Hindsight, etc.) can use for routing, filtering, and processing.

---

## MERC-013: Structured ScoreResult

**Status:** ðŸ”² Not Started

### Problem

Current output is minimalâ€”just accept/reject and a score. Downstream systems need more detail.

### Solution

Return a rich `ScoreResult` with all label scores, categories, and flags.

### Output Schema

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoreResult {
    // Decision
    pub decision: Decision,
    pub score: f32,
    pub confidence: Confidence,

    // Category scores
    pub categories: CategoryScores,

    // All label scores (43 labels)
    pub labels: Vec<LabelScore>,

    // Flags for downstream routing
    pub flags: Flags,

    // Metadata
    pub metadata: Metadata,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CategoryScores {
    pub sentiment: f32,
    pub emotion: f32,
    pub outcome: f32,
    pub context: f32,
    pub negative: f32,
    pub temporal: f32,
    pub sensitivity: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Flags {
    // Negative flags (reasons for rejection)
    pub is_phatic: bool,
    pub is_filler: bool,
    pub is_acknowledgment: bool,
    pub is_repetition: bool,

    // Temporal flags
    pub is_temporal_update: bool,
    pub has_deadline: bool,
    pub has_schedule: bool,

    // Sensitivity flags
    pub is_sensitive: bool,
    pub is_confidential: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Metadata {
    pub timestamp: DateTime<Utc>,
    pub latency_ms: u64,
    pub model_version: String,
}
```

### JSON Output Example

```json
{
  "decision": "accept",
  "score": 0.87,
  "confidence": "high",
  "categories": {
    "sentiment": 0.35,
    "emotion": 0.45,
    "outcome": 0.87,
    "context": 0.72,
    "negative": 0.12,
    "temporal": 0.75,
    "sensitivity": 0.15
  },
  "labels": [
    { "name": "Commitment", "category": "outcome", "score": 0.91 },
    { "name": "Deadline", "category": "temporal", "score": 0.85 },
    { "name": "Task", "category": "context", "score": 0.78 }
  ],
  "flags": {
    "is_phatic": false,
    "is_filler": false,
    "is_acknowledgment": false,
    "is_repetition": false,
    "is_temporal_update": false,
    "has_deadline": true,
    "has_schedule": false,
    "is_sensitive": false,
    "is_confidential": false
  },
  "metadata": {
    "timestamp": "2026-02-02T10:30:00Z",
    "latency_ms": 87,
    "model_version": "0.3.0"
  }
}
```

### Files

- `src/score/result.rs` â€” Expand `ScoreResult`

### Tasks

- [ ] Expand `ScoreResult` struct
- [ ] Add `CategoryScores` breakdown
- [ ] Add `Flags` for downstream routing
- [ ] Add `Metadata` with timing
- [ ] Implement JSON serialization

### Acceptance Criteria

- Full label breakdown in output
- Flags for downstream routing
- Backward compatible (existing fields preserved)

---

## MERC-014: Temporal Metadata

**Status:** ðŸ”² Not Started

### Problem

Downstream temporal systems (like Zep) need to know about time-related content, but Merc doesn't extract specific temporal information.

### Solution

Add lightweight temporal metadata extraction for downstream use.

### Temporal Metadata

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemporalMetadata {
    // Processing timestamp
    pub processed_at: DateTime<Utc>,

    // Detected temporal signals (not parsed, just flagged)
    pub has_temporal_reference: bool,
    pub temporal_labels: Vec<String>,  // ["Deadline", "Schedule"]

    // Optional: raw temporal expressions found (simple regex)
    pub temporal_expressions: Vec<String>,  // ["by Friday", "next week"]
}
```

### Temporal Expression Detection

Simple regex-based detection (not full parsing):

```rust
lazy_static! {
    static ref TEMPORAL_PATTERNS: Vec<Regex> = vec![
        Regex::new(r"(?i)\b(by|before|after|until)\s+\w+day\b").unwrap(),
        Regex::new(r"(?i)\b(next|last|this)\s+(week|month|year)\b").unwrap(),
        Regex::new(r"(?i)\b(tomorrow|yesterday|today)\b").unwrap(),
        Regex::new(r"\b\d{1,2}[/\-]\d{1,2}([/\-]\d{2,4})?\b").unwrap(),
        Regex::new(r"(?i)\b(january|february|march|...|december)\s+\d{1,2}\b").unwrap(),
    ];
}

fn extract_temporal_expressions(text: &str) -> Vec<String> {
    TEMPORAL_PATTERNS.iter()
        .flat_map(|re| re.find_iter(text))
        .map(|m| m.as_str().to_string())
        .collect()
}
```

### Research Context

**Zep's bi-temporal model** tracks:
- `t_valid`: When fact became true
- `t_invalid`: When fact stopped being true
- `t'_created`: When ingested
- `t'_expired`: When invalidated

Merc can't do bi-temporal reasoning (stateless), but providing temporal metadata enables downstream systems to:
1. Flag potential contradictions (`is_temporal_update`)
2. Extract deadlines for calendar integration
3. Build temporal indexes

### Files

- `src/score/temporal.rs` (new)
- `src/score/result.rs` â€” Add `TemporalMetadata`

### Tasks

- [ ] Create `TemporalMetadata` struct
- [ ] Implement regex-based expression detection
- [ ] Add to `ScoreResult`
- [ ] Document limitations (detection, not parsing)

### Acceptance Criteria

- Temporal flags in output
- Raw expressions extracted
- Clear documentation on scope (detection only)

---

## Downstream Integration Patterns

### With Zep

```rust
// Merc scores, Zep stores
let score_result = merc.score(&text, context.as_deref());

if score_result.decision == Decision::Accept {
    // Use temporal flags for Zep's bi-temporal model
    let zep_metadata = ZepMetadata {
        has_temporal_update: score_result.flags.is_temporal_update,
        has_deadline: score_result.flags.has_deadline,
        temporal_expressions: score_result.temporal.temporal_expressions,
    };

    zep.add_episode(&text, zep_metadata)?;
}
```

### With Hindsight

```rust
// Merc scores, Hindsight stores in epistemic networks
let score_result = merc.score(&text, context.as_deref());

if score_result.decision == Decision::Accept {
    // Route to appropriate Hindsight network based on labels
    let network = if score_result.labels.contains("Fact") {
        Network::World
    } else if score_result.labels.contains("Commitment") {
        Network::Experience
    } else if score_result.labels.contains("Preference") {
        Network::Opinion
    } else {
        Network::World  // default
    };

    hindsight.retain(&text, network)?;
}
```

### With Enterprise Systems

```rust
// Merc scores, enterprise system applies compliance
let score_result = merc.score(&text, context.as_deref());

if score_result.decision == Decision::Accept {
    // Use sensitivity flags for compliance routing
    let retention = if score_result.flags.is_confidential {
        Retention::Days(30)
    } else if score_result.flags.is_sensitive {
        Retention::Days(90)
    } else {
        Retention::Default
    };

    enterprise.store(&text, retention)?;
}
```

---

## Export Formats

### JSON (default)

```bash
merc score "I'll have it done by Friday" --format json
```

### CSV (for analysis)

```bash
merc score --batch input.txt --format csv > results.csv
```

### Protobuf (for performance)

Future consideration for high-throughput scenarios.

---

## Testing Requirements

- [ ] JSON schema validation
- [ ] Temporal expression regex tests
- [ ] Integration tests with mock downstream systems
- [ ] Backward compatibility tests

---

## Summary

Phase 5 completes the Merc improvement roadmap by providing rich, structured output that enables seamless integration with downstream memory systems.

| Phase | Focus | Latency | Status |
|-------|-------|---------|--------|
| [1. Foundation](./1.foundation.md) | Quick wins | 0% | ðŸ”² |
| [2. Labels](./2.labels.md) | Expanded taxonomy | +10-15% | ðŸ”² |
| [3. Context](./3.context.md) | Context + ensemble | +50-100% | ðŸ”² |
| [4. Learning](./4.learning.md) | Feedback loops | 0% | ðŸ”² |
| [5. Output](./5.output.md) | Structured output | 0% | ðŸ”² |

Return to [README](./README.md) for overview.
